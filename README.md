# 开发文档

## 代码整体思路
代码分为四个部分
```dtd
--> CodingSet类的实现
--> HuffmanFolderCompressor
--> HuffmanFolderDecompressor
--> Main(MainGUI)
```

```dtd
--> CodingSet类用来实现Huffman编码的构造
--> HuffmanFolderCompressor用来实现文件夹的压缩
        其中通过递归找到文件，并将文件路径，将文件名
        文件的哈夫曼编码集等一并存储在映射表中，并利用
        java的序列化将其写入到压缩后的文件中进行保存
--> HuffmanFolderDecompressor用来实现文件的解压缩
        其中通过java的序列化（注意顺序）来读出文件
        名称，路径，以及编码表，然后就是对文件进行
        配对解压缩
--> Main(GUIMain)用来实现用户操作
```

## 对核心问题的解决

>文件的压缩与解压缩 

（1）最主要的就是注意Buffered的输入输出流的操作，如果单个字节的读取太慢
缓冲区我选择的比较打，MB单位的，这样会快一些

（2）第二就是说注意不要一次将文件全部读入，例如，我在解压缩的时候我用字符串
来表示我的压缩后的文件流，如果一次性读入的话，由于字符串在内存中以字符数组
的形式存储，需要分配下标，而下标时整形的，所以当下标超过21亿，也就是文件
接近G单位时，会报错OutOfMemory，Heap溢出，这个是更改堆大小改变不了的，
因为它超过数组的最大可能长度

（3）第三，文件名的还原，我在压缩递归的时候，用一个HashMap来存储文件的路径,
然后用WriteObject将其用java序列化的形式写进去，然后在解压缩的时候，readObject
再读出来，就相对方便地来实现这一功能，但是也存在弊端，就是当我的文件太大的时候
java自带的序列化就会成为一个效率瓶颈，网上推荐可以用kryo什么外部的一些java序列化
的方法，还能跨平台跨语言，蛮好的，但是XML文件我目前写不明白


>文件夹的压缩与解压缩

（1）这个里面的像路径保存问题我在上一个里面说的差不多了，就是用Hashmap然后java序列化

（2）文件夹的递归java也有函数isDirectory()方法可以用，很方便

>设置压缩密码

（1）当我需要密码的时候，我输入Yes，然后就输出，请输入密码

（2）再用Java的序列化储存进去，需要的时候再读出来

（3）相当于把密码保存在了文件头中，尽管不安全，但是尽力了，助教大人

>用户交互

（1）如果是在终端（Main）只需要输入zip initPath zippedPath，或者upZip zippedPath unzippedPath

（2）如果需要用图形界面（GUIMain），则在提示框输入就行了

>鲁棒性

使用try，catch捕获异常并抛出文件未找到，使得对用户更为友好

>文件的覆盖问题

当解压缩时，文件已经存在时，我需要询问用户是否覆盖掉原文件（这个只在Main生效，GUIMain还不支持此功能）
## 性能测试

```dtd
total -- 3.77G  -- 2.58G   -- 68.435%
01    -- 0      -- 0.193KB -- \\\\\\\
02    -- 23.9MB -- 17.6MB  -- 73.640%
03    -- 1.11GB -- 0.709GB -- 63.919%
04    -- 0      -- 2KB     -- \\\\\\\
05    -- 6MB    -- 4.3MB   -- 71.667%
06    -- 448MB  -- 466MB   -- 104.018%
07    -- 1.1GB  -- 0.698GB -- 63.455%
08    -- 643.4MB-- 411.7MB -- 63.988%
09    -- 441.8MB-- 277.1MB -- 62.720%
```

## 遇到的问题

>一次性读入的话，由于字符串在内存中以字符数组的形式存储，需要分配下标，而下标时整形的，所
以当下标超过21亿，也就是文件接近G单位时，会报错OutOfMemory，Heap溢出

设置一个batch的最大大小，分块从文件读入，既保证效率，又保证不会整形溢出

>序列化读入找不到对象

按照写进去的顺序，来读出，这样才能保证查找到相应目标